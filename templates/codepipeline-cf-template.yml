# Copyright [2018] [Phil Chen]
# Copyright [2019] [Alicia Smith] * Added multiple inputs 
# as well as codecommit source and lambda merge functionality
# drawing from inspiration here:
# https://github.com/tooltwist/codepipeline-artifact-munge

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

AWSTemplateFormatVersion: 2010-09-09

Description: 'This solution allows you to create a AWS Codepipline for deploying a serverless application with AWS CodeBuild triggered by a CodeCommit or Github repo commit. The setup of this solution is fully automated via a CloudFormation template.'

Parameters:
  Environment:
    AllowedValues:
    - dev
    - stg
    - prod
    Description: Environment
    Type: String
    Default: dev

  Service:
    Description: The name of the service/external resource that will utilise this pipeline, e.g. zoom2mozdef.
    Type: String
    Default: template
    ConstraintDescription: "Can contain only ASCII characters."

  CodePipelineBucketPrefix:
    Description: CodePipeline needs a utility bucket for its internal use. Specify a unique prefix for the bucket name.
    Type: String
    Default: mozdef-ef-utility-bucket

  HelperBucket:
    Description: An EXISTING bucket which holds the merger lambda function code and codecommit code.
    Type: String
    Default: mozdef-ef-helper-bucket

  CodeCommitRepositoryBranch:
    Description: The name of the branch for the CodeCommit repo.
    Type: String
    Default: master
    ConstraintDescription: "Can contain only ASCII characters."
  
  # Removed personal access token parameter as it is accessed from 
  # AWS Secrets Manager
  GitHubRepository:
    Type: String
    # Defaulting to our public PoC repo
    Default: mozilla/mozdef-event-framework-template/master
    Description:  Github repository to be used as a source, in the form of "owner/repository/branch".

  ConfigDirectory:
    Type: String
    Default: config
    Description: Directory name for private configuration files for the merger lambda function.

# This helps grouping similar parameters together when deploying via AWS Console
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Stack Configuration"
        Parameters:
          - Environment
          - Service
          - CodePipelineBucketPrefix
          - HelperBucket
      - Label:
          default: "GitHub Configuration"
        Parameters:
          - GitHubRepository
      - Label:
          default: "CodeCommit Configuration"
        Parameters:
          - CodeCommitRepositoryBranch
          - ConfigDirectory

Resources:
  
  CodeCommitRepository:
    Type: AWS::CodeCommit::Repository
    Properties: 
      RepositoryDescription: CodeCommit repository to hold configuration files for the external source
      RepositoryName: !Join [ "", [ !Ref Service, "-ef-config" ]]
      Code:
        S3:
          Bucket: !Join [ "", [!Ref HelperBucket ]]
          # Hardcoding the name of the zip file containing
          # the skeleton/template files in the Codecommit repo 
          # (this does not have to change)
          Key: !Join [ "", [ "template-ef-config.zip" ]]

  CloudWatchCodeCommitEventRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName:
        'Fn::Join': [ "", ["CloudWatchCodeCommitEventRole", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      # I think this is OK
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
            Effect: "Allow"
            Principal:
              Service: "events.amazonaws.com"
            Action: "sts:AssumeRole"
      Path: /
  
  CloudwatchCodeCommitEventPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName:
        'Fn::Join': [ "", ["CloudwatchCodeCommitEventPolicy", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      # This is already restricted
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: codepipeline:StartPipelineExecution
            Resource: !Join [ '', [ 'arn:aws:codepipeline:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !Ref Pipeline] ]
      Roles:
        - !Ref CloudWatchCodeCommitEventRole

  CloudWatchCommitEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source: 
          - aws.codecommit
        detail-type: 
          - "CodeCommit Repository State Change"
        resources: 
          # - !Join [ '', [ 'arn:aws:codecommit:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !GetAtt 'CodeCommitRepository.Arn' ] ]
          - !GetAtt 'CodeCommitRepository.Arn'
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          repositoryName:
            - !GetAtt 'CodeCommitRepository.Name'
          referenceName:
            - !Ref CodeCommitRepositoryBranch
      Targets:
        -
          Arn: !Join [ '', [ 'arn:aws:codepipeline:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !Ref Pipeline] ]
          RoleArn: !GetAtt 'CloudWatchCodeCommitEventRole.Arn'
          Id: !Ref Pipeline

  CodeBuildRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName:
        'Fn::Join': [ "", ["CodeBuildRole", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: "Allow"
          Principal:
            Service: "codebuild.amazonaws.com"
          Action: "sts:AssumeRole"

  # This can be restricted more
  CodeBuildPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName:
        'Fn::Join': [ "", ["CodeBuildPolicy", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      # This is one of the most tricky ones, we may have
      # to break the permissions down per resource
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - 'codebuild:*'
            Resource: !GetAtt TestBuildDeploy.Arn
          - Effect: Allow
            Action:
              - 'codecommit:GetBranch'
              - 'codecommit:GetCommit'
              - 'codecommit:UploadArchive'
              - 'codecommit:GetUploadArchiveStatus'
              - 'codecommit:CancelUploadArchive'
            Resource: !GetAtt 'CodeCommitRepository.Arn'
          - Effect: Allow
            Action:
              - 'cloudformation:ListChangeSets'
              - 'cloudformation:ListStackResources'
              - 'cloudformation:GetStackPolicy'
              - 'cloudformation:GetTemplate'
              - 'cloudformation:CreateStack'
              - 'cloudformation:DeleteStack'
              - 'cloudformation:DescribeStacks'
              - 'cloudformation:DescribeStackResources'
              - 'cloudformation:DescribeStackResource'
              - 'cloudformation:DescribeStackEvents'
              - 'cloudformation:UpdateStack'
            Resource: !Join [ '', [ 'arn:aws:cloudformation:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "stack/", !Ref 'AWS::StackName' , "/*"  ] ]
          - Effect: Allow
            Action:
              - 'lambda:AddPermission'
              - 'lambda:CreateAlias'
              - 'lambda:DeleteFunction'
              - 'lambda:InvokeFunction'
              - 'lambda:PublishVersion'
              - 'lambda:RemovePermission'
              - 'lambda:UpdateAlias'
              - 'lambda:UpdateFunctionCode'
              - 'lambda:UpdateFunctionConfiguration'
            Resource:
              # Giving permissions on the lambda functions created 
              # by the serverless framework, based on the assumption
              # that serverless frameworks creates function names
              # based on service name and stage
              - !Join [ '', [ 'arn:aws:lambda:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "function", ':', !Ref Service, "-", !Ref Environment, "*" ] ]
              # Our merger lambda function
              - !GetAtt MergeLambda.Arn
          - Effect: Allow
            Action:
              - 'apigateway:GET'
              - 'apigateway:POST'
              - 'apigateway:PUT'
              - 'apigateway:DELETE'
              - 'apigateway:PATCH'
            # Note: This is still not ideal (giving access to all API
            # gateway resources in a region for a single account), 
            # but I could not find how to restrict it even further
            Resource: !Join [ '', [ 'arn:aws:apigateway:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "/restapis/*" ] ]
          - Effect: Allow
            Action:
              - 's3:CreateBucket'
              - 's3:DeleteBucket'
              - 's3:ListBucket'
              - 's3:ListBucketVersions'
              - 's3:PutObject'
              - 's3:GetObject'
              - 's3:DeleteObject'
              - 's3:PutEncryptionConfiguration'
              - 's3:GetEncryptionConfiguration'
            # NOTE: The below is probably not true. Some permissions
            # require "conditions", and I am not sure how to define them yet.
            Resource: 
              - !GetAtt S3CodePipeline.Arn
              - !Join [ '', [ 'arn:aws:s3:::', !Ref HelperBucket ] ]
              - !Join [ '', [ !GetAtt S3CodePipeline.Arn, '/*' ] ]
              - !Join [ '', [ 'arn:aws:s3:::', !Ref HelperBucket, '/*' ] ]
          - Effect: Allow
            Action:
              - 'iam:PassRole'
              - 'iam:GetRole'
              - 'iam:CreateRole'
              - 'iam:PutRolePolicy'
              - 'iam:DeleteRolePolicy'
              - 'iam:DeleteRole'
            # Also not sure about this one
            Resource: 
              # - !Join [ '', [ 'arn:aws:iam:', !Ref 'AWS::AccountId', ':role/', !Ref CodeBuildRole ] ]
              - !GetAtt CodeBuildRole.Arn
          - Effect: Allow
            Action:
              - 'events:RemoveTargets'
              - 'events:DeleteRule'
            Resource: !Join [ '', [ 'arn', !Ref 'AWS::Partition', ':events:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':rule/', !Ref CloudWatchCodeCommitEventRule ] ]
          - Effect: Allow
            Action:
              - 'ssm:PutParameter'
              - 'ssm:GetParameter'
              - 'ssm:GetParametersByPath'
            Resource: !Join [ '', [ 'arn:aws:ssm:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':parameter/*' ] ]
          - Effect: Allow
            Action:
              - 'ssm:AddTagsToResource'
            Resource: !Join [ '', [ 'arn:aws:ssm:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':document/*' ] ]
          - Effect: Allow
            Action:
              - 'sqs:CreateQueue'
              - 'sqs:SendMessage'
              - 'sqs:GetQueueAttributes'
              - 'sqs:ListQueues'
            Resource: !Join [ '', [ 'arn:aws:sqs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':*' ] ]
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:DeleteLogGroup'
              - 'logs:DescribeLogGroups'
              - 'logs:FilterLogEvents'
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*' ] ]
          - Effect: Allow
            Action:
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
              - 'logs:DescribeLogStreams'
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*:log-stream:*' ] ]
            # Seems like there are some permissions that are 
            # only applicable to "*" resource, maybe
          - Effect: Allow
            Action:
              - 'cloudformation:ListStacks'
              - 'cloudformation:GetTemplateSummary'
              - 'cloudformation:PreviewStackUpdate'
              - 'cloudformation:ValidateTemplate'
              - 'cloudformation:CreateUploadBucket'
              - 'cloudformation:DescribeAccountLimits'
              - 'cloudformation:DescribeChangeSet'
              - 'lambda:CreateFunction'
              - 'lambda:PublishLayerVersion'
              - 'cloudwatch:GetMetricStatistics'
              - 'events:PutEvents'
              - 'events:PutRule'
              - 'events:PutTargets'
            Resource: "*"
      Roles:
        -  !Ref CodeBuildRole

  CodePipelineRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName:
        'Fn::Join': [ "", ["CodePipelineRole", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: "Allow"
          Principal:
            Service: "codepipeline.amazonaws.com"
          Action: "sts:AssumeRole"

  CodePipelinePolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName:
        'Fn::Join': [ "", ["CodePipelinePolicy", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*' ] ]
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*:log-stream:*' ] ]
          - Effect: Allow
            Action:
              - s3:putObject
              - s3:getObject
            Resource:
              # NOTE: The below is probably not true. Some permissions
              # require "conditions", and I am not sure how to define them yet.
              - !Join [ '', [ !GetAtt S3CodePipeline.Arn, '/*' ] ]
              - !Join [ '', [ 'arn:aws:s3:::', !Ref HelperBucket, '/*' ] ]
          - Effect: Allow
            Action:
              - codecommit:GetBranch
              - codecommit:GetCommit
              - codecommit:UploadArchive
              - codecommit:GetUploadArchiveStatus
              - codecommit:CancelUploadArchive
            # Resource: !GetAtt CodeCommitRepository.Arn
            Resource: !Join [ '', [ 'arn:aws:codecommit:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', !Ref CodeCommitRepository ] ]
          - Effect: Allow
            Action:
              - lambda:InvokeFunction
            Resource:
              # Giving permissions on the lambda functions created 
              # by the serverless framework, based on the assumption
              # that serverless frameworks creates function names
              # based on service name and stage
              - !Join [ '', [ 'arn:aws:lambda:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "function", ':', !Ref Service, "-", !Ref Environment, "*" ] ]
              # Our merger lambda function
              - !GetAtt MergeLambda.Arn
          - Effect: Allow
            Action:
              - secretsmanager:GetSecretValue
            Resource: !Join [ '', [ 'arn:aws:secretsmanager:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "secret", ':', !Ref Environment, '/codepipeline/github' ] ]
          - Effect: Allow
            Action:
              - codebuild:*
            Resource: !GetAtt TestBuildDeploy.Arn
      Roles:
        -  !Ref CodePipelineRole
  
  CodePipelineLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        'Fn::Join': [ "", ["CodePipelineLambdaRole", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      Path: /
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: "Allow"
          Principal:
            Service: "lambda.amazonaws.com"
          Action: "sts:AssumeRole"

  CodePipelineLambdaPolicy:
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName:
        'Fn::Join': [ "", ["CodePipelineLambdaPolicy", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObject
              - s3:GetObjectVersion
            Resource:
              # NOTE: The below is probably not true. Some permissions
              # require "conditions", and I am not sure how to define them yet.
              - !Join [ '', [ !GetAtt S3CodePipeline.Arn, '/*' ] ]
              - !Join [ '', [ 'arn:aws:s3:::', !Ref HelperBucket, '/*' ] ]
          - Effect: Allow
            Action:
              - s3:GetBucketVersioning
            Resource:
              - !GetAtt S3CodePipeline.Arn
              - !Join [ '', [ 'arn:aws:s3:::', !Ref HelperBucket ] ]
          - Effect: Allow
            Action:
              - codecommit:GetBranch
              - codecommit:GetCommit
              - codecommit:UploadArchive
              - codecommit:GetUploadArchiveStatus
              - codecommit:CancelUploadArchive
            Resource: !GetAtt CodeCommitRepository.Arn
          - Effect: Allow
            Action:
              - codebuild:StartBuild
              - codebuild:BatchGetBuilds
            Resource: !GetAtt TestBuildDeploy.Arn
          - Effect: Allow
            Action:
              - codepipeline:PutJobSuccessResult
              - codepipeline:PutJobFailureResult
              - lambda:*
            Resource: "*"
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource: 
              # Also not sure about this one
              # - !Join [ '', [ 'arn:aws:iam:', !Ref 'AWS::AccountId', ':role/', !Ref CodePipelineLambdaRole ] ]
              - !GetAtt CodePipelineLambdaRole.Arn
          - Effect: Allow
            Action:
              - cloudformation:*
            Resource: !Join [ '', [ 'arn:aws:cloudformation:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':', "stack/", !Ref 'AWS::StackName' , "/*"  ] ]
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*' ] ]
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: !Join [ '', [ 'arn:aws:logs:', !Ref 'AWS::Region', ':', !Ref 'AWS::AccountId', ':log-group:/*:log-stream:*' ] ]
      Roles:
        -  !Ref CodePipelineLambdaRole
  
  S3CodePipeline:
    Type: "AWS::S3::Bucket"
    Properties:
      BucketName: !Join [ "", [!Ref CodePipelineBucketPrefix,  "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
  
  MergeLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName:
        'Fn::Join': [ "", ["CodePipelineMergeLambda", "-", !Ref 'AWS::StackName', "-", !Ref 'Environment']]
      Code:
        # Using the HelperBucket parameter here
        S3Bucket: !Join [ "", [!Ref HelperBucket ]]
        S3Key: merge.zip
      Role: !GetAtt 'CodePipelineLambdaRole.Arn'
      Description: "Lambda Function to merge artifacts in CodePipeline"
      Timeout: 30
      Handler: "merge.handler"
      Runtime: "nodejs10.x"
      MemorySize: 128

  TestBuildDeploy:
    Type: "AWS::CodeBuild::Project"
    Properties:
      Name: !Join ["", ["Test-Build",  "-", !Ref 'AWS::StackName'] ]
      Description: Demo of CodeBuild with CodeDeploy pipeline.
      ServiceRole: !Ref CodeBuildRole
      TimeoutInMinutes: 5
      Source:
        Type: CODEPIPELINE
        BuildSpec: !Join [ "", [!Ref 'ConfigDirectory', "/", "buildspec", "-", !Ref 'Environment', ".yml"]]
      Environment:
        Type: "LINUX_CONTAINER"
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:2.0
      Artifacts:
        Type: CODEPIPELINE

  # CodePipeline with its stages:
  Pipeline:
    Type: "AWS::CodePipeline::Pipeline"
    Properties:
      Name: !Join [ "", ["DevOps-Pipeline", "-", !Ref 'AWS::StackName'] ]
      ArtifactStore:
        Location: !Ref S3CodePipeline
        Type: S3
      RestartExecutionOnUpdate: true
      RoleArn: !GetAtt CodePipelineRole.Arn
      Stages:

        # Stage 1:  Get the source from CodeCommit, and then from the Github repo
        - Name: Source
          Actions:
            - Name: ConfigSource
              RunOrder: 1
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeCommit
                Version: 1
              Configuration:
                BranchName: !Ref CodeCommitRepositoryBranch
                RepositoryName: !GetAtt 'CodeCommitRepository.Name'
                PollForSourceChanges: false
              OutputArtifacts:
                - Name: ConfigSourceOutput
            - Name: CodeSource
              RunOrder: 1
              ActionTypeId:
                Category: Source
                Owner: ThirdParty
                Provider: GitHub
                Version: 1
              Configuration:
                Owner: !Select [0, !Split [ "/" , !Ref GitHubRepository ]]
                Repo: !Select [1, !Split [ "/" , !Ref GitHubRepository ]]
                Branch: !Select [2, !Split [ "/" , !Ref GitHubRepository ]]
                # Since we are not using a webhook, we need to poll
                PollForSourceChanges: true
                # Obtaining from Secrets Manager
                OAuthToken: !Join [ "", [ "{{resolve:secretsmanager:", !Ref Environment, "/codepipeline/github:SecretString:PersonalAccessToken}}" ]]
              OutputArtifacts:
                - Name: CodeSourceOutput

        # Stage 2: Merge the Sources into one Artifact
        # This merges the App and SecureConfig artifacts
        # See https://dzone.com/articles/running-aws-lambda-functions-in-aws-codepipeline-u
        - Name: Merge
          Actions:
            - Name: Merge-App-and-Config
              ActionTypeId:
                Category: Invoke
                Owner: AWS
                Version: 1
                Provider: Lambda
              Configuration:
                FunctionName: !Ref MergeLambda
                UserParameters: !Ref ConfigDirectory
              InputArtifacts:
                - Name: CodeSourceOutput
                - Name: ConfigSourceOutput
              OutputArtifacts:
                - Name: Build-Ready
              RunOrder: 2
  
        # Stage 3:  Build using Serverless Framework
        - Name: TestBuildDeploy
          Actions:
            - Name: !Join [ "", ["TestBuildDeploy",  "-", !Ref 'AWS::StackName'] ]
              RunOrder: 3
              InputArtifacts:
                - Name: Build-Ready
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: 1
              Configuration:
                ProjectName:  !Ref TestBuildDeploy
              OutputArtifacts:
                - Name: Deploy-Ready

Outputs:
  CodeBuild:
    Value: !Ref Pipeline
  Environment:
    Value: !Ref Environment
  CodecommitRepo:
    Value: !GetAtt 'CodeCommitRepository.Name'
  CodecommitBranch:
    Value: !Ref CodeCommitRepositoryBranch
  GithubRepo:
    Value: !Ref GitHubRepository
  CodeBuildRole:
    Value: !Ref CodeBuildRole
  CodeBuildPolicy:
    Value: !Ref CodeBuildPolicy
  CodePipelineRole:
    Value: !Ref CodePipelineRole
  CodePipelineLambdaRole:
    Value: !Ref CodePipelineLambdaRole
  CodePipelinePolicy:
    Value: !Ref CodePipelinePolicy
  CodePipelineLambdaPolicy:
    Value: !Ref CodePipelineLambdaPolicy
  S3Codepipeline:
    Value: !Ref S3CodePipeline
